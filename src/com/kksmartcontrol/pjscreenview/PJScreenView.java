package com.kksmartcontrol.pjscreenview;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import java.util.ArrayList;import java.util.List;/** * TODO: document your custom view class. *  * author:BigBigBoy */public class PJScreenView extends View {	public PJScreenView(Context context, AttributeSet attrs, int defStyleAttr) {		super(context, attrs, defStyleAttr);		// TODO Auto-generated constructor stub	}	public PJScreenView(Context context, AttributeSet attrs) {		this(context, attrs, 0);		// TODO Auto-generated constructor stub	}	public PJScreenView(Context context) {		this(context, null, 0);		// TODO Auto-generated constructor stub	}	// 绘制内容	private Paint contentPaint = new Paint(Paint.DITHER_FLAG);	// 绘制 边缘线	private Paint edgePaint = new Paint(Paint.DITHER_FLAG);	{ // 设置抗锯齿		contentPaint.setAntiAlias(true);		// contentPaint.setDither(true);		// 设置样式		contentPaint.setStyle(Paint.Style.FILL);		contentPaint.setStrokeWidth(5);		contentPaint.setTextSize(20);		// 设置抗锯齿		edgePaint.setAntiAlias(true);		// edgePaint.setDither(true);		// 设置样式		edgePaint.setStyle(Paint.Style.STROKE);	}	// 屏幕中所有拼接屏幕集合	List<PJCell> cellList = new ArrayList<PJCell>();	// 拼接屏的行列值	int ROW, COLUMN;	// 拼接子屏幕宽度	int cellWidth;	// 拼接子屏幕高度	int cellHeight;	// 标识线的起点和终点坐标	float lineStartX, lineStartY, lineStopX, lineStopY;	// 用于在ontouch中判断滑动时切换子屏幕事件，其它地方不会使用	PJCell tempCell, actionDownCell;	// 用于判断手指滑动时是否出现了标识线条	boolean isLineShowing = false;	// 标识当前是否处于手动单击选择（非滑动选择）,默认为true；isLineShowing被置为true时则将其设置为false	boolean isClicking = true;	// 选择的PJCell列表	private List<PJCell> selectedCellList = new ArrayList<PJCell>();	/**	 * Simple constructor to use when creating a view from code.	 * 	 * @param context	 *            The Context the view is running in, through which it can	 *            access the current theme, resources, etc.	 */	public PJScreenView(Context context, int ROW, int COLUMN) {		super(context);		initCellList(ROW, COLUMN);	}	/**	 * 提供的外部方法设置行列值，设置完成后将立即刷新界面	 * 	 * @param ROW	 *            拼接的行数	 * @param COLUMN	 *            拼接的列数	 */	public void setSplicesMode(int ROW, int COLUMN) {		cellList.clear();		initCellList(ROW, COLUMN);		invalidate();	}	/**	 * 初始化子屏幕集合	 * 	 * @param ROW	 *            拼接的行数	 * @param COLUMN	 *            拼接的列数	 */	private void initCellList(int ROW, int COLUMN) {		this.ROW = ROW;		this.COLUMN = COLUMN;		for (int i = 0; i < ROW;) {			++i;			for (int j = 0; j < COLUMN;) {				cellList.add(new PJCell(++j, i));			}		}	}	@Override	protected void onDraw(Canvas canvas) {		super.onDraw(canvas);		drawCacheBitmap(canvas);		Log.d("onDraw", " onDrawonDrawonDraw");	}	/**	 * 循环执行所有CELL的绘制方法到bitmap	 */	void drawCacheBitmap(Canvas canvas) {		cellWidth = getWidth() / COLUMN;		cellHeight = getHeight() / ROW;		canvas.scale(getWidth() / (float) (cellWidth * COLUMN), getHeight()				/ (float) (cellHeight * ROW));		for (PJCell cell : cellList) {			// PJCell.draw(cell, cellWidth, cellHeight, canvas);			drawCell(cell, canvas);		}		if (isLineShowing) {			contentPaint.setColor(Color.RED);			contentPaint.setStrokeWidth(5);			edgePaint.setARGB(60, 30, 90, 20);			edgePaint.setStrokeWidth(8);			canvas.drawLine(lineStartX, lineStartY, lineStopX, lineStopY,					contentPaint);			canvas.drawCircle(lineStartX, lineStartY, 12, contentPaint);			canvas.drawCircle(lineStartX, lineStartY, 12, edgePaint);		}	}	/**	 * 绘制子视图	 * 	 * @param cell	 *            子屏幕元素	 */	private void drawCell(PJCell cell, Canvas cacheCanvas) {		// Log.d("getHeight", "getHeight---> " + getHeight());		float xLocation = (cell.columnNum - 1) * cellWidth;		float yLocation = (cell.rowNum - 1) * cellHeight;		if (cell.isSelected()) {			contentPaint.setColor(PJCell.selectCellColor);			edgePaint.setColor(PJCell.selectLineColor);		} else {			contentPaint.setColor(cell.cellColor);			edgePaint.setColor(cell.lineColor);		}		// 设置画笔宽度		edgePaint.setStrokeWidth(2);		cacheCanvas.drawRect(xLocation + 1, yLocation + 1, xLocation				+ cellWidth - 1, yLocation + cellHeight - 1, contentPaint);		cacheCanvas.drawRect(xLocation + 1, yLocation + 1, xLocation				+ cellWidth - 1, yLocation + cellHeight - 1, edgePaint);		contentPaint.setColor(Color.RED);		cacheCanvas.drawText(cell.getInputSignl(), xLocation + 8,				yLocation + 20, contentPaint);	}	@Override	public boolean onTouchEvent(MotionEvent event) {		switch (event.getAction()) {		case MotionEvent.ACTION_DOWN:			actionDownCell = getCell(event.getX(), event.getY());			tempCell = actionDownCell;			lineStartX = (float) ((actionDownCell.columnNum - 0.5) * cellWidth);			lineStartY = (float) ((actionDownCell.rowNum - 0.5) * cellHeight);			break;		case MotionEvent.ACTION_MOVE:			PJCell actionMoveCell = getCell(event.getX(), event.getY());			if (actionMoveCell != null) {				boolean isEqual = actionMoveCell.equals(tempCell);				if (isLineShowing || !isEqual) {					if (!isEqual) {						refreshSelectedCell(actionDownCell, actionMoveCell);						tempCell = actionMoveCell;					}					disPlayIdentifyLine(event);				}			} else {				disPlayIdentifyLine(event);			}			break;		case MotionEvent.ACTION_UP:			PJCell actionUpCell = getCell(event.getX(), event.getY());			if (actionUpCell != null) {				if (actionDownCell.equals(actionUpCell)) {					if (!isClicking) {						setAllCellUnSelected();						isClicking = true;					}					actionUpCell.setSelectState(!actionUpCell.isSelected());				}			}			invalidate();			isLineShowing = false;			break;		default:			break;		}		return true;	}	/**	 * 用于显示手指在不同拼接屏幕间滑动的指示线	 * 	 * @param event	 *            touch事件	 */	private void disPlayIdentifyLine(MotionEvent event) {		isClicking = false;		isLineShowing = true;		lineStopX = event.getX();		lineStopY = event.getY();		invalidate();	}	/**	 * 判断触摸点是否在View坐标范围内，当手指滑动速度过快时，获得的坐标会特别大，以至于超出View边界	 * 	 * @param x	 *            手指当前点相对于 PJScreenView左上角的横坐标值	 * @param y	 *            手指当前点相对于 PJScreenView左上角的纵坐标值	 * @return 手指坐标点在View内部时返回true，否则返回false	 */	private boolean isTouchPointInPJScreenView(final float x, final float y) {		return (!(x > getWidth() || y < 0 || x < 0 || y > getHeight()));	}	/**	 * 通过坐标找到对应的子屏幕对象	 * 	 * @param x	 *            手指当前点相对于 PJScreenView左上角的横坐标值	 * @param y	 *            手指当前点相对于 PJScreenView左上角的纵坐标值	 * @return 当前手指所在CELL	 */	private PJCell getCell(final float x, final float y) {		// Log.d("getCell", "\ngetHeight---> " + getHeight() + "\ngetWidth---> "		// + getWidth() + "\nx---> " + x + "\ny---> " + y);		if (isTouchPointInPJScreenView(x, y)) {			// (getWidth() / (float) COLUMN)) 是为了获得具体的宽度，不能使用cellWidth，			// 因为cellWidth是int类型，舍掉了小数部分，在需要细微区分时就会出现问题			// 也不能使用 (float) (getWidth() / COLUMN)) ，因为具体结果是按照分母的类型判断的，			// 分母为int，那么除法结果就是int，此后的强制转换只是将int转为float			// 分母为float，那么除法结果就是float			int columnNum = (int) (x / (getWidth() / (float) COLUMN)) + 1;			int rowNum = (int) (y / (getHeight() / (float) ROW)) + 1;			int listIndex = (rowNum - 1) * COLUMN + columnNum - 1;			return cellList.get(listIndex);		} else			return null;	}	/**	 * 将所有拼接屏幕置为未选择状态	 */	private void setAllCellUnSelected() {		for (PJCell cell : cellList) {			cell.setSelectState(false);		}	}	/**	 * 刷新选中的CELL，它和按下点和手指当前点有关	 * 	 * @param touchDownCell	 *            手指按下处的CELL	 * @param touchMoveCell	 *            手指当前CELL	 */	private void refreshSelectedCell(PJCell touchDownCell, PJCell touchMoveCell) {		int minColumn = (touchDownCell.columnNum < touchMoveCell.columnNum) ? touchDownCell.columnNum				: touchMoveCell.columnNum;		int minRow = (touchDownCell.rowNum < touchMoveCell.rowNum) ? touchDownCell.rowNum				: touchMoveCell.rowNum;		int maxColumn = (touchDownCell.columnNum > touchMoveCell.columnNum) ? touchDownCell.columnNum				: touchMoveCell.columnNum;		int maxRow = (touchDownCell.rowNum > touchMoveCell.rowNum) ? touchDownCell.rowNum				: touchMoveCell.rowNum;		for (PJCell cell : cellList) {			if (((cell.rowNum >= minRow) && (cell.rowNum <= maxRow))					&& ((cell.columnNum >= minColumn) && (cell.columnNum <= maxColumn))) {				cell.setSelectState(true);			} else {				cell.setSelectState(false);			}		}	}	int colorIndex;	int[][] groupColorSet = { { Color.CYAN, Color.YELLOW },			{ Color.CYAN, Color.MAGENTA }, { Color.YELLOW, Color.TRANSPARENT },			{ Color.CYAN, Color.BLUE }, { Color.WHITE, Color.rgb(10, 30, 30) },			{ Color.CYAN, Color.WHITE }, { Color.CYAN, Color.DKGRAY },			{ Color.CYAN, Color.BLACK } };	/**	 * @return 返回选择的屏幕集合	 */	public List<PJCell> getSelectList() {		selectedCellList.clear();		for (PJCell cell : cellList) {			if (cell.isSelected()) {				selectedCellList.add(cell);			}		}		return selectedCellList;	}	/**	 * 设置选中屏的输入信号	 * 	 * @param inputSignl	 *            输入信号名称	 */	public void setInputSignl(String inputSignl) {		int index = (colorIndex++) % 8;		for (PJCell cell : cellList) {			if (cell.isSelected()) {				cell.setSelectState(false);				cell.setInputSignl(inputSignl, groupColorSet[index][0],						groupColorSet[index][1]);			}		}		invalidate();	}}