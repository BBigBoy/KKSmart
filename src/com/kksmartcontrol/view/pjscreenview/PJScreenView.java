package com.kksmartcontrol.view.pjscreenview;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import com.kksmartcontrol.bean.Coordinate;import java.util.ArrayList;import java.util.List;/** * TODO: document your custom view class. * <p/> * author:BigBigBoy */public class PJScreenView extends View {    public PJScreenView(Context context, AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        // TODO Auto-generated constructor stub    }    public PJScreenView(Context context, AttributeSet attrs) {        this(context, attrs, 0);        // TODO Auto-generated constructor stub    }    public PJScreenView(Context context) {        this(context, null, 0);        // TODO Auto-generated constructor stub    }    // 绘制内容    private Paint contentPaint = new Paint(Paint.DITHER_FLAG);    // 绘制 边缘线    private Paint edgePaint = new Paint(Paint.DITHER_FLAG);    { // 设置抗锯齿        contentPaint.setAntiAlias(true);        // contentPaint.setDither(true);        // 设置样式        contentPaint.setStyle(Paint.Style.FILL);        contentPaint.setStrokeWidth(5);        contentPaint.setTextSize(20);        // 设置抗锯齿        edgePaint.setAntiAlias(true);        // edgePaint.setDither(true);        // 设置样式        edgePaint.setStyle(Paint.Style.STROKE);    }    // 屏幕中所有拼接屏幕集合    List<PJCell> cellList = new ArrayList<PJCell>();    // 拼接屏的行列值    int ROW, COLUMN;    // 拼接子屏幕宽度    int cellWidth;    // 拼接子屏幕高度    int cellHeight;    // 标识线的起点和终点坐标    float lineStartX, lineStartY, lineStopX, lineStopY;    // 用于在ontouch中判断滑动时切换子屏幕事件，其它地方不会使用    PJCell tempCell, actionDownCell;    // 用于判断手指滑动时是否出现了标识线条    boolean isLineShowing = false;    // 标识当前是否处于手动单击选择（非滑动选择）,默认为true；isLineShowing被置为true时则将其设置为false    boolean isClicking = true;    // 选择的PJCell列表    private List<PJCell> selectedCellList = new ArrayList<PJCell>();    /**     * Simple constructor to use when creating a view from code.     *     * @param context The Context the view is running in, through which it can     *                access the current theme, resources, etc.     */    public PJScreenView(Context context, int ROW, int COLUMN) {        super(context);        initCellList(ROW, COLUMN);    }    /**     * 提供的外部方法设置行列值，设置完成后将立即刷新界面     *     * @param ROW    拼接的行数     * @param COLUMN 拼接的列数     */    public void setSplicesMode(int ROW, int COLUMN) {        cellList.clear();        initCellList(ROW, COLUMN);        invalidate();    }    /**     * 初始化子屏幕集合     *     * @param ROW    拼接的行数     * @param COLUMN 拼接的列数     */    private void initCellList(int ROW, int COLUMN) {        this.ROW = ROW;        this.COLUMN = COLUMN;        for (int i = 0; i < ROW; ) {            ++i;            for (int j = 0; j < COLUMN; ) {                cellList.add(new PJCell(++j, i));            }        }    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        drawCacheBitmap(canvas);        Log.d("onDraw", " onDrawonDrawonDraw");    }    /**     * 循环执行所有CELL的绘制方法到bitmap     */    void drawCacheBitmap(Canvas canvas) {        cellWidth = getWidth() / COLUMN;        cellHeight = getHeight() / ROW;        canvas.scale(getWidth() / (float) (cellWidth * COLUMN), getHeight()                / (float) (cellHeight * ROW));        for (PJCell cell : cellList) {            // PJCell.draw(cell, cellWidth, cellHeight, canvas);            drawCell(cell, canvas);        }        if (isLineShowing) {            contentPaint.setColor(Color.RED);            contentPaint.setStrokeWidth(5);            edgePaint.setARGB(60, 30, 90, 20);            edgePaint.setStrokeWidth(8);            canvas.drawLine(lineStartX, lineStartY, lineStopX, lineStopY,                    contentPaint);            canvas.drawCircle(lineStartX, lineStartY, 12, contentPaint);            canvas.drawCircle(lineStartX, lineStartY, 12, edgePaint);        }    }    /**     * 绘制子视图     *     * @param cell 子屏幕元素     */    private void drawCell(PJCell cell, Canvas cacheCanvas) {        // Log.d("getHeight", "getHeight---> " + getHeight());        float xLocation = (cell.columnNum - 1) * cellWidth;        float yLocation = (cell.rowNum - 1) * cellHeight;        if (cell.isSelected()) {            contentPaint.setColor(PJCell.selectCellColor);            edgePaint.setColor(PJCell.selectLineColor);        } else {            contentPaint.setColor(cell.cellColor);            edgePaint.setColor(cell.lineColor);        }        // 设置画笔宽度        edgePaint.setStrokeWidth(2);        cacheCanvas.drawRect(xLocation + 1, yLocation + 1, xLocation                + cellWidth - 1, yLocation + cellHeight - 1, contentPaint);        cacheCanvas.drawRect(xLocation + 1, yLocation + 1, xLocation                + cellWidth - 1, yLocation + cellHeight - 1, edgePaint);        contentPaint.setColor(Color.RED);        cacheCanvas.drawText(cell.getInputSignl(), xLocation + 8,                yLocation + 20, contentPaint);    }    @Override    public boolean onTouchEvent(MotionEvent event) {        switch (event.getAction()) {            case MotionEvent.ACTION_DOWN:                actionDownCell = getCell(event.getX(), event.getY());                tempCell = actionDownCell;                lineStartX = (float) ((actionDownCell.columnNum - 0.5) * cellWidth);                lineStartY = (float) ((actionDownCell.rowNum - 0.5) * cellHeight);                break;            case MotionEvent.ACTION_MOVE:                PJCell actionMoveCell = getCell(event.getX(), event.getY());                if (actionMoveCell != null) {                    boolean isEqual = actionMoveCell.equals(tempCell);                    if (isLineShowing || !isEqual) {                        if (!isEqual) {                            refreshSelectedCell(actionDownCell, actionMoveCell);                            tempCell = actionMoveCell;                        }                        disPlayIdentifyLine(event);                    }                } else {                    disPlayIdentifyLine(event);                }                break;            case MotionEvent.ACTION_UP:                PJCell actionUpCell = getCell(event.getX(), event.getY());                if (actionUpCell != null) {                    if (actionDownCell.equals(actionUpCell)) {                        if (!isClicking) {                            setAllCellUnSelected();                            isClicking = true;                        }                        actionUpCell.setSelectState(!actionUpCell.isSelected());                    }                }                invalidate();                isLineShowing = false;                break;            default:                break;        }        return true;    }    /**     * 用于显示手指在不同拼接屏幕间滑动的指示线     *     * @param event touch事件     */    private void disPlayIdentifyLine(MotionEvent event) {        isClicking = false;        isLineShowing = true;        lineStopX = event.getX();        lineStopY = event.getY();        invalidate();    }    /**     * 判断触摸点是否在View坐标范围内，当手指滑动速度过快时，获得的坐标会特别大，以至于超出View边界     *     * @param x 手指当前点相对于 PJScreenView左上角的横坐标值     * @param y 手指当前点相对于 PJScreenView左上角的纵坐标值     * @return 手指坐标点在View内部时返回true，否则返回false     */    private boolean isTouchPointInPJScreenView(final float x, final float y) {        return (!(x > getWidth() || y < 0 || x < 0 || y > getHeight()));    }    /**     * 通过坐标找到对应的子屏幕对象     *     * @param x 手指当前点相对于 PJScreenView左上角的横坐标值     * @param y 手指当前点相对于 PJScreenView左上角的纵坐标值     * @return 当前手指所在CELL     */    private PJCell getCell(final float x, final float y) {        // Log.d("getCell", "\ngetHeight---> " + getHeight() + "\ngetWidth---> "        // + getWidth() + "\nx---> " + x + "\ny---> " + y);        if (isTouchPointInPJScreenView(x, y)) {            // (getWidth() / (float) COLUMN)) 是为了获得具体的宽度，不能使用cellWidth，            // 因为cellWidth是int类型，舍掉了小数部分，在需要细微区分时就会出现问题            // 也不能使用 (float) (getWidth() / COLUMN)) ，因为具体结果是按照分母的类型判断的，            // 分母为int，那么除法结果就是int，此后的强制转换只是将int转为float            // 分母为float，那么除法结果就是float            int columnNum = (int) (x / (getWidth() / (float) COLUMN)) + 1;            int rowNum = (int) (y / (getHeight() / (float) ROW)) + 1;            int listIndex = (rowNum - 1) * COLUMN + columnNum - 1;            return cellList.get(listIndex);        } else            return null;    }    /**     * 将所有拼接屏幕置为未选择状态     */    private void setAllCellUnSelected() {        for (PJCell cell : cellList) {            cell.setSelectState(false);        }    }    /**     * 刷新选中的CELL，它和按下点和手指当前点有关     *     * @param touchDownCell 手指按下处的CELL     * @param touchMoveCell 手指当前CELL     */    private void refreshSelectedCell(PJCell touchDownCell, PJCell touchMoveCell) {        int minColumn = (touchDownCell.columnNum < touchMoveCell.columnNum) ? touchDownCell.columnNum                : touchMoveCell.columnNum;        int minRow = (touchDownCell.rowNum < touchMoveCell.rowNum) ? touchDownCell.rowNum                : touchMoveCell.rowNum;        int maxColumn = (touchDownCell.columnNum > touchMoveCell.columnNum) ? touchDownCell.columnNum                : touchMoveCell.columnNum;        int maxRow = (touchDownCell.rowNum > touchMoveCell.rowNum) ? touchDownCell.rowNum                : touchMoveCell.rowNum;        for (PJCell cell : cellList) {            if (((cell.rowNum >= minRow) && (cell.rowNum <= maxRow))                    && ((cell.columnNum >= minColumn) && (cell.columnNum <= maxColumn))) {                cell.setSelectState(true);            } else {                cell.setSelectState(false);            }        }    }    int colorIndex;    int[][] groupColorSet = {{Color.CYAN, Color.YELLOW},            {Color.CYAN, Color.MAGENTA}, {Color.YELLOW, Color.TRANSPARENT},            {Color.CYAN, Color.BLUE}, {Color.WHITE, Color.rgb(10, 30, 30)},            {Color.CYAN, Color.WHITE}, {Color.CYAN, Color.DKGRAY},            {Color.CYAN, Color.BLACK}};    /**     * @return 返回选择的屏幕集合     */    public List<PJCell> getSelectList() {        selectedCellList.clear();        for (PJCell cell : cellList) {            if (cell.isSelected()) {                selectedCellList.add(cell);            }        }        return selectedCellList;    }    /**     * 设置选中屏的输入信号     *     * @param inputSignl 输入信号名称     */    public void setInputSignl(String inputSignl) {        int index = (colorIndex++) % 8;        for (PJCell cell : cellList) {            if (cell.isSelected()) {                cell.setSelectState(false);                cell.setInputSignl(inputSignl, groupColorSet[index][0],                        groupColorSet[index][1]);            }        }        invalidate();    }    /**     * @return 判断是否存在选中的屏幕     */    public boolean isSelectListEmpty() {        // TODO Auto-generated method stub        return getSelectList().isEmpty();    }    /**     * @return 返回选择的屏幕集合坐标     */    public List<Coordinate> getCoordinateList() {        // TODO Auto-generated method stub        List<Coordinate> coordinateList = new ArrayList<Coordinate>();        List<PJScreenView.PJCell> selectList = getSelectList();        Log.d("getCoordinateListlllll", "\n\nselectList.size()---->"                + selectList.size());        for (PJScreenView.PJCell cell : selectList) {            coordinateList.add(new Coordinate(cell.rowNum, cell.columnNum));            Log.d("getCoordinateList", "\n\n---->" + cell);        }        Log.d("getCoordinateListlllll", "\n\ncoordinateList.size()---->"                + coordinateList.size());        return coordinateList;    }    /**     * Created by BBBoy on 2014/12/19.     */    public static class PJCell {        // 用于设置边缘宽度        // public static int lineDegree;        //        // public static void setLineDegree(int lineDegree) {        // PJCell.lineDegree = lineDegree;        // }        public static int selectLineColor = Color.GREEN;        public static int selectCellColor = Color.CYAN;        private boolean selectState = false;        public int rowNum, columnNum;        public String inputSignl = "VGA";        public int lineColor = Color.BLUE;        public int cellColor = Color.GREEN;        public boolean isSelected() {            return selectState;        }        public void setSelectState(boolean selectState) {            this.selectState = selectState;        }        int backLight = 100;        int[] rgbPlus = {128, 128, 128};        int[] picMode = {40, 40, 50, 12};        public void setInputSignl(String inputSignl, int lineColor, int cellColor) {            this.inputSignl = inputSignl;            this.lineColor = lineColor;            this.cellColor = cellColor;        }        public String getInputSignl() {            return inputSignl;        }        public PJCell(int columnNum, int rowNum) {            this.columnNum = columnNum;            this.rowNum = rowNum;        }        @Override        public String toString() {            return "PJCell{" + "rowNum=" + rowNum + ", columnNum=" + columnNum                    + '}';        }        //        // public int getLineColor() {        // return lineColor;        // }        //        // public void setLineColor(int lineColor) {        // this.lineColor = lineColor;        // }        //        // public int getCellColor() {        // return cellColor;        // }        //        // public void setCellColor(int cellColor) {        // this.cellColor = cellColor;        // }        /*         * //PJCell自己提供的绘制方法，暂时不使用 public static void draw(PJCell cell, int         * cellWidth, int cellHeight, Canvas cacheCanvas) {         *         * float xLocation = (cell.columnNum - 1) * cellWidth; float yLocation =         * (cell.rowNum - 1) * cellHeight; paint.setColor(cell.cellColor);         * cacheCanvas.drawRect(xLocation, yLocation, xLocation + cellWidth,         * yLocation + cellHeight, paint); paint.setColor(cell.lineColor);         * cacheCanvas.drawLine(xLocation, yLocation, xLocation + cellWidth,         * yLocation, paint); cacheCanvas.drawLine(xLocation + cellWidth, yLocation,         * xLocation + cellWidth, yLocation + cellHeight, paint);         * cacheCanvas.drawLine(xLocation, yLocation + cellHeight, xLocation +         * cellWidth, yLocation + cellHeight, paint);         * cacheCanvas.drawLine(xLocation, yLocation, xLocation, yLocation +         * cellHeight, paint); }         */    }}